const SQRT3X2 = Math.sqrt(3) * 2;

/**
 * Represents a hexagonal grid using a 1D array with hexagon IDs (hexId) starting from a center position of 0
 * and "spiraling" outwards incremeniting each ID by 1. Technically, the grid is formed using
 * concentric rings of hexagons that surround the previous layer rather than strictly spiraling.
 * 
 * Does not implent graphical rendering. An external graphics/game library can be used to draw the grid based on the 
 * coordinates generated by this class using the hexCenters array property. maxHexId and layers may be useful as well
 * to determine the borders/edge of the grid.
 * 2D coordinates increment going right (x) and down (y) for ease of use with many graphics libraries.
 */
export class HexGrid {

    // TODO 
    // Rotation

    // TODO
    // Wrap around

    // TODO 
    // Offset

    constructor( layers, scale = 1 ) {
        // Set input properties
        this.layers = layers;
        this.scale = scale;

        // Calculate properties
        this.maxHexId = 3 * (layers + 1) * layers;
        this.hexagonPoints = [0, -2/SQRT3X2*scale, 0.5*scale, -1/SQRT3X2*scale, 0.5*scale, 1/SQRT3X2*scale, 0, 2/SQRT3X2*scale, -0.5*scale, 1/SQRT3X2*scale, -0.5*scale, -1/SQRT3X2*scale];
        
        // Calculate center positions of hexagons
        this.hexCenters = [];
        this.directions = [];
        this.calculateHexagonCenters();

        // Calculate min and max X and Y values
        this.calculateGridBorders();
    }

    setScale( scale ){
        this.scale = scale;
        this.calculateHexagonCenters();
    }

    calculateHexagonCenters() {
        // Set direction constants
        const RIGHT = this.vector2(1, 0);
        const UP_RIGHT = this.vector2(0.5, -3/SQRT3X2);
        const UP_LEFT = this.vector2(-0.5, -3/SQRT3X2);
        const LEFT = this.vector2(-1, 0);
        const DOWN_LEFT = this.vector2(-0.5, 3/SQRT3X2);
        const DOWN_RIGHT = this.vector2(0.5, 3/SQRT3X2);
        const BASE_DIRECTIONS = [ RIGHT, DOWN_RIGHT, DOWN_LEFT, LEFT, UP_LEFT, UP_RIGHT];

        // Scale direction vectors
        for (let i = 0; i < BASE_DIRECTIONS.length; i++) { 
            this.directions[i] = this.multiplyVector(BASE_DIRECTIONS[i], this.scale);
        }

        let currentHexCenter = this.vector2(0, 0);
        let hexId = 0;
        for (let currentLayer = 0; currentLayer <= this.layers; currentLayer++) {
            this.hexCenters[hexId] = this.vector2(currentHexCenter.x, currentHexCenter.y);
                
            // Move UP_RIGHT until top left corner
            for(let i = 0; i < currentLayer - 1; i++) {  
                currentHexCenter = this.addVectors(currentHexCenter, this.directions[5]);
                hexId++;   
                this.hexCenters[hexId] = this.vector2(currentHexCenter.x, currentHexCenter.y);
            }
    
            // Move other direction
            for(let i = 0; i < this.directions.length - 1; i++) {     
                for(let j = 0; j < currentLayer; j++){
                    currentHexCenter = this.addVectors(currentHexCenter, this.directions[i]);
                    hexId++;
                    this.hexCenters[hexId] = this.vector2(currentHexCenter.x, currentHexCenter.y);      
                }
            }
    
            // Move to next layer
            if (currentLayer < this.layers) {
                currentHexCenter = this.addVectors(currentHexCenter, this.directions[4])
                hexId++;  
            }   
        }
    }

    calculateGridBorders(){
        this.maxX = this.maxY = -Infinity;
        this.minX = this.minY = Infinity;
        for(let i = 0; i < this.hexCenters.length; i++) {  
            if ( this.hexCenters[i].x > this.maxX ) {
                this.maxX = this.hexCenters[i].x;
            }
            if ( this.hexCenters[i].x < this.minX ) {
                this.minX = this.hexCenters[i].x;
            }
            if ( this.hexCenters[i].y > this.maxY ) {
                this.maxY = this.hexCenters[i].y;
            }
            if ( this.hexCenters[i].y < this.minY ) {
                this.minY = this.hexCenters[i].y;
            } 
        }
        this.width = this.maxX - this.minX;
        this.height = this.maxY - this.minY;
    }

    /**
     * Adds two vectors together.
     *
     * @param {vector} vec1 - The first vector to be added.
     * @param {vector} vec2 - The second vector to be added.
     * @return {vector} Returns a new vector that is the sum of vec1 and vec2.
     */
    addVectors(vec1, vec2) {
        return { "x": vec1.x + vec2.x, "y": vec1.y + vec2.y };
    }

    /**
     * Multiplies a vector by a scalar.
     *
     * @param {vector} vector - The vector to be multiplied.
     * @param {number} scalar - The scalar to multiply the vector by.
     * @return {vector} The resulting multiplied vector.
     */
    multiplyVector(vector, scalar) {
        return { "x": vector.x * scalar, "y": vector.y * scalar };
    }

    /**
     * Calculates the distance between two vectors.
     *
     * @param {vector} vec1 - The first vector.
     * @param {vector} vec2 - The second vector.
     * @return {number} The distance between the two vectors.
     */
    vectorDistance(vec1, vec2){
        return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
    }

    /**
     * Creates a new Vector2 object with the given x and y values.
     *
     * @param {number} x - The x value of the vector.
     * @param {number} y - The y value of the vector.
     * @return {vector} - The new Vector2 object with x and y properties.
     */
    vector2(x, y){
        return {"x": x, "y": y};
    }

    // Implement only given a seperate world view coordinate
    // Currently this class only implements a constent internal coordate system
    // i.e. the positions of the hexagons never change.
    /**
     * Finds the hexagon that contains the given position.
     *
     * @param {vector} position - The position vector to be checked.
     * @return {int} The hexId of the hexagon that contains position.
    //  */
    // function hexIdAtPosition( position ) {
    //     let shortestDistance = Infinity;
    //     let closestHexId = 0;
    //     for (let i = 0; i < hexCenters.length; i++) {
    //         let distanceToHex = hexCenters[i].dist(createVector(position.x, position.y));
    //         if (distanceToHex < shortestDistance) {
    //             shortestDistance = distanceToHex;
    //             closestHexId = i;
    //         }
    //     }
    //     return closestHexId;
    // } 


    /**
     * Finds the hexagon that contains the given position.
     *
     * @param {vector} position - The position vector to be checked.
     * @return {int} The hexId of the hexagon that contains position.
     */
    hexIdAtPosition( position ) {
        let shortestDistance = Infinity;
        let closestHexId = 0;
        for (let i = 0; i < this.hexCenters.length; i++) {
            let distanceToHex = hexCenters[i].dist(this.vector2(position.x, position.y));
            if (distanceToHex < shortestDistance) {
                shortestDistance = distanceToHex;
                closestHexId = i;
            }
        }
        return closestHexId;
    } 

    /**
     * Calculates the starting hexId of the layer of a given hexID.
     *
     * @param {int} hexId - The hexId that is within the layer to check.
     * @return {int} The starting hexId of the layer.
     */
    layerStartHexId( hexId ){
        return 3 * ( this.layerOf(hexId) ) * ( this.layerOf(hexId) - 1) + 1;
    }

    /**
     * Calculate the starting hexId of the next layer.
     *
     * @param {int} hexId - The hex ID of the current layer.
     * @return {int} The starting hex ID of the next layer.
     */
    nextLayerStartHexId( hexId ){
        return 3 * ( this.layerOf(hexId) + 1 ) * this.layerOf(hexId) + 1;
    }

    /**
     * Calculates the starting hexId of the previous layer to a given hexagon.
     *
     * @param {int} hexId - The hexId of the hexagon to check.
     * @return {int} The starting hexId of the previous layer.
     */
    previousLayerStartHexId( hexId ){
        return 3 * ( this.layerOf(hexId) - 1 ) * ( this.layerOf(hexId) - 2 ) + 1;
    }

    /**
     * Calculates the position of a hexagon within its layer.
     *
     * @param {int} hexId - The hexId of the hexagon to check.
     * @return {int} The position of the hexagon within its layer.
     */
    positionInLayer( hexId ){
        return hexId - this.layerStartHexId(hexId);
    }

    /**
     * Returns the hexId of the hexagon at a given layer and corner position
     * @param {int} layer the layer to check
     * @param {int} corner position to check
     * corners: 0 (Top Left), 1 (Top Right), 2 (Right), 3 (Bottom Right), 4 (Bottom Left), 5 (Left)
     * @return {int} the hexId of the corner hexagon in the checked position
     */
    cornerHex( layer, corner ){
        return ( (3*layer) - (2-corner) ) * layer;
    }

    /**
     * Checks if the given hexId is in a corner hexagon position within its layer.
     *
     * @param {int} hexId - The hexId to be checked.
     * @return {bool} true if the hexId is a corner hexagon, false otherwise
     */
    isCornerHex( hexId ){
        return ( hexId == this.layerOf(hexId) * round( hexId/this.layerOf(hexId) ) );
    }
    
    /**
     * Calculates the number of hexagons in the layer of a given hexId
     *
     * @param {int} hexId - The hexId of a hexagon within the layer to check.
     * @return {int} The number of hexagons in the layer.
     */
    hexagonsInLayer( hexId ){
        return layerOf(hexId) * 6;
    }
        
    /**
     * The layer number of the given HexId
     * Starts with center hexagon layer of 0
     * 
     * @param {int} hexId - The hexId to be checked
     * @return {int} The layer number (distance from center) of the given hexId

     */
    layerOf( hexId ) {
        return Math.round( Math.sqrt(hexId/3) );
    }

    /**
     * The section/direction/side of the given HexId
     * 
     * Each section corresponds to a direction/side of each layer/ring
     * 0 (Top Left), 1 (Top), 2 (Top Right), 3 (Bottom Right), 4 (Bottom), 5 (Bottom Left)
     * Section 0 includes both left and top left corners. Section 5 includes no corners.   
     * All other sections only include their last corner.
     * 
     * @param {int} hexId to check.
     * @return {int} The section/direction/side that the given hexId is located in.
     */
    sectionOf(hexId) {
        if ( hexId == 0 ) return 0;
        return Math.floor(this.positionInLayer( hexId  ) / ( this.layerOf( hexId ) * 6 ) * 6);
    }

    /**
     * The up-left neighbor of the given hexId.
     *
     * @param {int} hexId - The hexId of the hexagon to check.
     * @return {int} The hexId of the up-left neighbor of the given hexagon.
     */
    upLeftNeighbor(hexId) {
        const section = this.sectionOf(hexId);
        const layer = this.layerOf(hexId);
        const sqrt6 =  Math.round(Math.sqrt(hexId / 3)) * 6;
        
        switch (section) {
            case 0:
            case 1:
                return hexId + sqrt6 + 1;
            case 2:
                return hexId - 1;
            case 3:
                return 2 - (sqrt6 - hexId);
            case 4:
                if (hexId !== this.cornerHex(layer, 4)) {
                    return hexId - sqrt6 + 2;
                }
            default:
                return hexId + 1;
        }
    }


    /**
     * The up-right neighbor of the given hexId.
     *
     * @param {int} hexId - The hexId of the hexagon to check.
     * @return {int} The hexId of the up-right neighbor of the given hexagon.
     */
    upRightNeighbor(hexId) {
        const layer = this.layerOf(hexId);
        const section = this.sectionOf(hexId);
        const sqrt6 = Math.round(Math.sqrt(hexId / 3)) * 6;

        switch (section) {
            case 0:
                return hexId !== this.cornerHex(layer, 0) ? hexId + 1 : hexId + sqrt6 + 2;
            case 3:
                return hexId - 1;
            case 4:
            case 5:
                return hexId - sqrt6 + 1;
            default:
                return hexId + sqrt6 + 2;
        }
    }

    /**
     * The right neighbor of the given hexId.
     *
     * @param {int} hexId - The hexId of the hexagon to check.
     * @return {int} The hexId of the right neighbor of the given hexagon.
     */
    rightNeighbor(hexId) {
        const section = this.sectionOf(hexId);
        const layer = this.layerOf(hexId);
        const sqrt6 = Math.round(Math.sqrt(hexId/3)) * 6;

        switch (section) {
            case 0:
                return hexId == this.cornerHex(layer, 0) ? hexId + 1 : hexId - sqrt6 + 6;
            case 1:
                return hexId == this.cornerHex(layer, 1) ? hexId + sqrt6 + 3 : hexId + 1;
            case 2:
            case 3:
                return hexId + sqrt6 + 3;
            case 4:
                return hexId - 1;
            case 5:
                return hexId - sqrt6;
        }

    }

    /**
     * The down-right neighbor of the given hexId.
     *
     * @param {int} hexId - The hexId of the hexagon to check.
     * @return {int} The hexId of the down-right neighbor of the given hexagon.
     */
    downRightNeighbor(hexId) {
        const section = this.sectionOf(hexId);
        const layer = this.layerOf(hexId);
        const sqrt6 = Math.round(Math.sqrt(hexId/3)) * 6;
        switch (section) {
            case 0:
                if (this.positionInLayer(hexId) == 0){
                    return hexId - 1;
                }
            case 1:
                return hexId === this.cornerHex(layer, 1) ? hexId + 1 : hexId - sqrt6 + 5;
            case 2:
                return hexId === this.cornerHex(layer, 2) ? hexId + sqrt6 + 4 : hexId + 1;
            case 3:
            case 4:
                return hexId + sqrt6 + 4;
            default:
                return hexId - 1;
        }
    }

    /**
     * The down-left neighbor of the given hexId.
     *
     * @param {int} hexId - The hexId of the hexagon to check.
     * @return {int} The hexId of the down-left neighbor of the given hexagon.
     */
    downLeftNeighbor(hexId) {
        const layer = this.layerOf(hexId);
        const section = this.sectionOf(hexId);
        const sqrt6 = Math.round(Math.sqrt(hexId / 3)) * 6;

        switch (section) {
            case 0:
                if(this.positionInLayer(hexId) == 0){
                    return hexId + sqrt6 - 1;
                }  
                return hexId - 1;          
            case 1:
            case 2:
                return hexId === this.cornerHex(layer, 2) ? hexId + 1 : hexId - sqrt6 + 4;
            case 3:
                return hexId === this.cornerHex(layer, 3) ? hexId + sqrt6 + 5 : hexId + 1;
            case 4: 
            default:
                return hexId + sqrt6 + 5; 
        }
    }

    /**
     * The left neighbor of the given hexId.
     *
     * @param {int} hexId - The hexId of the hexagon to check.
     * @return {int} The hexId of the left neighbor of the given hexagon.
     */
    leftNeighbor(hexId) {
        const layer = this.layerOf(hexId);
        const section = this.sectionOf(hexId);
        const sqrt6 = Math.round(Math.sqrt(hexId / 3)) * 6;

        switch (section) {
            case 0:
                return hexId + sqrt6;
            case 1:
                return hexId - 1;
            case 2:
            case 3:
                return hexId === this.cornerHex(layer, 3) ? hexId + 1 : hexId - sqrt6 + 3;
            case 4:
                return hexId === this.cornerHex(layer, 4) ? hexId + sqrt6 + 6 : hexId + 1;
            case 5:
                return hexId + sqrt6 + 6;
            default:
                return hexId;
        }
    }

    /**
     * Generates a list of neighbors for a given hexagon.
     *
     * @param {int} hexId - The hexId of the hexagon to check.
     * @return {Array} An array containing the hexIds of the neighboring hexagons.
     */
    neighborsOf( hexId ){
        if (hexId == 0) return [1,2,3,4,5,6];
        
        let neighbors = [];
        let upLeftNeighborId = this.upLeftNeighbor(hexId);
        let upRightNeighborId = this.upRightNeighbor(hexId);
        let rightNeighborId = this.rightNeighbor(hexId);
        let downRightNeighborId = this.downRightNeighbor(hexId);
        let downLeftNeighborId = this.downLeftNeighbor(hexId);
        let leftNeighborId = this.leftNeighbor(hexId);
        
        if (upLeftNeighborId <= this.maxHexId){
            neighbors.push(upLeftNeighborId);
        }
        if (upRightNeighborId <= this.maxHexId){
            neighbors.push(upRightNeighborId);
        }
        if (rightNeighborId <= this.maxHexId){
            neighbors.push(rightNeighborId);
        }
        if (downRightNeighborId <= this.maxHexId){
            neighbors.push(downRightNeighborId);
        }
        if (downLeftNeighborId <= this.maxHexId){
            neighbors.push(downLeftNeighborId);
        }
        if (leftNeighborId <= this.maxHexId){
            neighbors.push(leftNeighborId);
        }
        
        return neighbors;
    }

}